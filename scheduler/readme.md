개요
o1 스케줄러를 이용해서 구현
o1 스케줄러는 active와 expired 두 개의 우선순위 배열을 이용해 프로세스간 우선순위를 구별
active에 실행가능한 프로세스를 저장해두고 타임 슬라이스를 모두 소비한 프로세스는 expired에 옮긴다.
프로세스를 생성할 때 우선순위에 해당하는 위치에 저장하며 스케줄링시 앞에서부터 꺼내기 때문에 프로세스간 우선 순위의 비교없이 스케줄링이 가능
0번 프로세스는 idle프로세스로 프로세스간 스위칭은 이 프로세스에서 진행한다. 
스케줄링이 진행되면 0번 프로세스가 현재 프로세스로 스위칭 
실행하기로 결정된 프로세스를 찾은뒤 다시 0번 프로세스와 스위칭을 한다.
다른 프로세스가 cpu를 중지하고 점유할수 있기 때문에 빠른 응답이 가능
선점형 스케줄링 방식으로 여러 프로세스를 동시에 실행하는 경우에 효율적이고 공평

2. 상세 설계
scheduler – 스케줄링이 일어날 때 먼저 호출되는 함수로써 우선 현재 프로세스의 타임 슬라이스를 검사해서
타임 슬라이스를 넘겻다면 expired 배열로 해당 프로세스를 이동시킨다.
그리고 현재 프로세스가 idle이 아니라면 idle로 스위칭 한다. 
이때 스위칭 과정에서 발생하는 인터럽트를 막아준다. 
그리고 실행시킬 프로세스를 찾아야하는데 만약 없다면 active 와 expired를 교체 해준다. 
그리고 다시 찾는다. 만약 이때도 없다면 현재 active와 expired 둘다 비어있으므로 실행시킬 프로세스가 없으므로 스케줄링을 종료해준다. 
성공적으로 찾아온 프로세스는 실행을 하기 위해 준비를 한뒤 현재 sleep중인 프로세스중 io가 끝났다면 프로세스의 상태를 run으로 바꾼뒤 스위칭을 진행한다.
이때에도 인터럽트를 무시하는 코드를 추가한다.  
sched_find_set - 스케줄링 과정에서 호출되며 active에서 프로세스가 있는 제일 빠른 우선순위의 리스트를 찾아서 get_next_proc에 넘겨준다.
scheduler에 프로세스를 리턴한다   
get_next_proc – 받은 리스트를 검사해서 리스트 안의 프로세스들의 state를 조사한다. 
이때 실행 가능한 프로세스 즉, run 상태의 프로세스를 sched_find_set 에 리턴해준다.
스케줄링 자료구조 구현 방법 – priority array는 두 개로 각각 pr_pool1, 2에 각 프로세스의 옵션으로 받은 우선순위에 해당하는 위치의
리스트에 해당 프로세스의 생성시 넣어준다. 
두 array는 각각 active와 expired가 포인팅하며 스케줄링에 따라 서로 포인팅 대상을 맞바꾼다. 
time_sleep은 해당 프로세스의 io가 일어날 시점이므로 프로세스 생성시 옵션에 추가해 정해준다. 
이때 kernel_proc 1,2,3는 while문을 실행하며 자신의 프로세스가 실행될 때 반복 실행되므로 
여기서 현재 프로세스가 사용한 클럭수를 이용해 io와 종료 시점을 검사한다. 
그리고 io를 판단하여 프로세스의 상태가 변하는 시점과 스케줄링 시점이 다를수 있으므로 프로세스가 실행가능 상태일때만 사용 클럭을 증가시킨다.    
